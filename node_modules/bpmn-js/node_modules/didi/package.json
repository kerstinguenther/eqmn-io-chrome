{
  "name": "didi",
  "version": "0.0.4",
  "description": "Dependency Injection for JavaScript",
  "main": "lib/index.js",
  "scripts": {
    "test": "mocha --compilers coffee:coffee-script test/*"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/Nikku/di-di.git"
  },
  "keywords": [
    "di",
    "inversion of control",
    "dependency",
    "injection",
    "injector"
  ],
  "devDependencies": {
    "grunt": "~0.4",
    "grunt-simple-mocha": "~0.4",
    "grunt-contrib-jshint": "~0.6",
    "mocha": "~1.12",
    "chai": "~1.7",
    "coffee-script": "~1.6"
  },
  "author": {
    "name": "Vojta Jina",
    "email": "vojta.jina@gmail.com"
  },
  "license": "MIT",
  "readme": "# Dependency Injection for JavaScript\r\n\r\n[![Build Status](https://travis-ci.org/Nikku/didi.png?branch=master)](https://travis-ci.org/Nikku/didi)\r\n\r\n> A fork of [node-di](node-di) that adds support for the minification save array notation.\r\n\r\n## Why Dependency Injection?\r\nThere are two things - **Dependency Injection pattern** (aka Inversion of Control) and **Dependency Injection framework**.\r\n\r\nThe Dependency Injection pattern is about separating the instantiation of objects from the actual logic and behavior that they encapsulate. This pattern has many benefits such as:\r\n\r\n- **explicit dependencies** - all dependencies are passed in as constructor arguments, which makes it easy to understand how particular object depends on the rest of the environment,\r\n- **code reuse** - such an object is much easier to reuse in other environments, because it is not coupled to a specific implementation of its dependencies,\r\n- and **much easier to test**, because testing is essentially about instantiating a single object without the rest of the environment.\r\n\r\nFollowing this pattern is, of course, possible without any framework.\r\n\r\nHowever, if you do follow the Dependency Injection pattern, you typically end up with some kind of nasty `main()` method, where you instantiate all the objects and wire them together. The Dependency Injection framework saves you from this boilerplate. **It makes wiring the application declarative rather than imperative.** Each component declares its dependencies and the framework does transitively resolve these dependencies...\r\n\r\n\r\n## Example\r\n\r\n```js\r\nvar Car = function(engine) {\r\n  this.start = function() {\r\n    engine.start();\r\n  };\r\n};\r\n\r\nvar createPetrolEngine = function(power) {\r\n  return {\r\n    start: function() {\r\n      console.log('Starting engine with ' + power + 'hp');\r\n    }\r\n  };\r\n};\r\n\r\n\r\n// a module is just a plain JavaScript object\r\n// it is a recipe for the injector, how to instantiate stuff\r\nvar module = {\r\n  // if an object asks for 'car', the injector will call new Car(...) to produce it\r\n  'car': ['type', Car],\r\n  // if an object asks for 'engine', the injector will call createPetrolEngine(...) to produce it\r\n  'engine': ['factory', createPetrolEngine],\r\n  // if an object asks for 'power', the injector will give it number 1184\r\n  'power': ['value', 1184] // probably Bugatti Veyron\r\n};\r\n\r\n\r\nvar di = require('di');\r\nvar injector = new di.Injector([module]);\r\n\r\ninjector.invoke(function(car) {\r\n  car.start();\r\n});\r\n```\r\n\r\nFor more examples, check out [the tests](/Nikku/node-di/blob/master/test/injector.spec.coffee). You can also check out [Karma](https://github.com/karma-runner/karma) and its plugins for more complex examples.\r\n\r\n## Usage\r\n\r\n### On the web\r\n\r\nIf you are working on the web use the minification save array notation to declare types or factories and their respective dependencies:\r\n\r\n```javascript\r\nvar module = {\r\n  'car': ['type', [ 'engine', Car ]],\r\n  ...\r\n};\r\n\r\nvar di = require('di');\r\nvar injector = new di.Injector([module]);\r\n\r\ninjector.invoke(['car', function(car) {\r\n  car.start();\r\n}]);\r\n```\r\n\r\n### Registering stuff\r\n\r\n#### type(token, Constructor)\r\nTo produce the instance, `Constructor` will be called with `new` operator.\r\n```js\r\nvar module = {\r\n  'engine': ['type', DieselEngine]\r\n};\r\n```\r\n\r\n#### factory(token, factoryFn)\r\nTo produce the instance, `factoryFn` will be called (without any context) and its result will be used.\r\n```js\r\nvar module = {\r\n  'engine': ['factory', createDieselEngine]\r\n};\r\n```\r\n\r\n#### value(token, value)\r\nRegister the final value.\r\n```js\r\nvar module = {\r\n  'power': ['value', 1184]\r\n};\r\n```\r\n\r\n\r\n### Annotation\r\nThe injector looks up tokens based on argument names:\r\n```js\r\nvar Car = function(engine, license) {\r\n  // will inject objects bound to 'engine' and 'license' tokens\r\n};\r\n```\r\n\r\nYou can also use comments:\r\n```js\r\nvar Car = function(/* engine */ e, /* x._weird */ x) {\r\n  // will inject objects bound to 'engine' and 'x._weird' tokens\r\n};\r\n```\r\n\r\nYou can also the minification save array notation known from [AngularJS][AngularJS]:\r\n```js\r\nvar Car = [ 'engine', 'trunk', function(e, t) {\r\n  // will inject objects bound to 'engine' and 'trunk'\r\n}];\r\n```\r\n\r\nSometimes it is helpful to inject only a specific property of some object:\r\n```js\r\nvar Engine = function(/* config.engine.power */ power) {\r\n  // will inject 1184 (config.engine.power),\r\n  // assuming there is no direct binding for 'config.engine.power' token\r\n};\r\n\r\nvar module = {\r\n  'config': ['value', {engine: {power: 1184}, other : {}}]\r\n};\r\n```\r\n\r\n\r\n## Differences to ...\r\n\r\n#### [node-di][node-di]\r\n\r\n- support for array notation\r\n\r\n#### Angular DI\r\n\r\n- no config/runtime phases (configuration happens by injecting a config object)\r\n- no global module register\r\n- comment annotation\r\n- no decorators\r\n- service -> type\r\n- child injectors\r\n- private modules\r\n\r\n\r\n---------\r\n\r\nMade for NodeJS _and_ the web. Based on [node-di][node-di].\r\n\r\n\r\n[AngularJS]: http://angularjs.org/\r\n[node-di]: https://github.com/vojtajina/node-di\r\n\r\n\r\n<!--\r\nObject - a member of object graph in an application that can have dependencies on instances of other types (i.e. other Objects).\r\nToken - each Object dependency (not an Object itself) is identified via a Token. Token is typically an annotation, string constant or a class/type\r\nInjector - a container or context, capable of resolving Object dependencies and caching references to Objects constructed during the dependency resolution process.\r\nProvider - a recipe for constructing Objects, typically a constructor or factory function\r\nBinding - a mapping between a Token and a Provider\r\nModule - a set of bindings. A Module is used to configure an Injector and defines which Objects can be resolved via an Injector. Module can also be used to override Object definitions (for reconfiguration or mocking purposes). \r\n-->\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Nikku/di-di/issues"
  },
  "_id": "didi@0.0.4",
  "_from": "didi@^0.0.4"
}
